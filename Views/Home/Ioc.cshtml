@inject ASP_SPD111.Services.Hash.IHashService hashService
@{
    ViewData["Title"] = "Ioc";
}

<h1 class="display-4">Інверсія управління</h1>

<p>
    Інверсія управління (Ioc, Invertion of Control) - схема побудови архітектуру проєкту, 
    за якої управління життевим циклом об'єктів делегується окремому модулю. Життевий цикл - 
    CRUD - створення, впровадження, модифікація, видалення. 
    Ідея полягає у тому, що спочатку відбувається реєстрація служб - провайдерів об'єктів. 
    На другому єтапі відбувається роз'язування (Resolve) залежностей, тобто побудова об'єкту з 
    усіма заявленними залежностями від інших об'єктів (служб, сервісів).
</p>
<p>
    DIP (Dependency invertion principle) - принцип інверсії залежностей 
    (не плутати з IoC) - один з принципів SOLID, який пропонує стрворювати залежності 
    не від конкретних типів, а від інтерфейсів. Це дозволяє легко замінити один тип на інший, якщо вони 
    реалізують один інтерфейс.
</p>
<p>
    На прикладі служби гешування.
</p>
<ul>
    <li>
        Сервіси є структурною частиною проекту, більш того, часто мають універсальне 
        значення (можуть бути перенесені до іншого проєкту).
        Відповідно для них створюється папка на найвищому рівні.
    </li>
    <li>
        За рекомндаціями DIP/SOLID навіть одиночний сервіс-клас має супроводжуватись 
        інтерфейсом, тобто на один сервіс припадає декілька файлів-класів. Відповідно, 
        кожен з сервісів також уміщують в окрему папку ("Hash"). У ній створюємо інтерфейс та 
        клас. 
    </li>
    <li>
        Реєструємо сервіс. У Program.cs знаходимо разділ до 
        <code>var app = builder.Build();</code>
        та надаємо інструкцію реєстрації <br />
        <code>builder.Services.AddSingleton&lt;IHashService, Md5HashService>();</code><br/>
        Це можна уявити як: "Будуть запитувати IHashService - видати Md5HashService"
    </li>
    <li>
        Заявляємо залежності - у контролері створюємо поле типу IHashService 
        (див. HomeController)
    </li>
    <li>
        Уявляємо задачу переходу на іншу схему гешування. Для цього 
        <ul>
            <li>
                у папці /Services/Hash створюємо ще один клас, який реалізує той самий інтерфейс
                IHashService - Sha1HashService
            </li>
            <li>
                У Program.cs замінюємо інструкцію реєстрації з новим класом <br/> 
                <code>builder.Services.AddSingleton<IHashService, Sha1HashService>();</code>
            </li>
            <li>
                Перезапускаємо проєкт            
            </li>
        </ul>

    </li>
</ul>
<h2>Scope - область "життя" сервісу.</h2>
<p>
    При реєстрації служби зазначається ії scope - поведінка щодо повторних 
    запитів на інжекцію. У ASP є три області:
    <dfn>Singleton</dfn> - незмінний об'єкт, усі точки інжекції отримують посилання на один і той самий об'єкт.
    <dfn>Transient</dfn> - "одноразовий", кожна точка отримує новий об'єкт.
    <dfn>RequestScope(.Addscoped)</dfn> - постійний протягом одного запиту, наступний запит - нове створення об'єкту
    (як час життя контролерів).
</p>

<p>
    hash = @ViewData["hash"]<br/>
    hashCode(controller) = @ViewData["objHash"] <br/>
    hashCode(view) = @hashService.GetHashCode();
</p>